#include <Wire.h>
#include <math.h>
#include <max6675.h>
#include <PID_v1.h>
#include <Time.h>
#include <TimeLib.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
// I/O
#define RELAY_PIN 49  // Pin for PWM signal to the variator driver (ZeroPin 2 and the same GND)   //// Dimmer 
const int clk = 6;      // Pin 8 from rotary encoder direction
const int data = 5;     // Pin 9 from rotary encoder variation

// const int temperaturePrecision = 1;
const int temperatureOfSecurity = 300;

// Initial Variable
float temperature_read = 0.0;
float previous_error = 0;
float elapsedTime, Time, timePrev;

// PID variables
double Setpoint, Input, Output;
int WindowSize = 5000;
unsigned long windowStartTime, lastPrintTime;
unsigned long indicateur_boucle = 0;
 
// PID tuning parameters
double Kp = 15, Ki = 0, Kd = 0; // Initial value
double consKp = 15, consKi = 5, consKd = 1500; // Final values for regulation in the more stationary phase
double error;
double lastInput;
double dInput;
double errKp = 0, errKi = 0, errKd = 0;

// PID object
PID myPID(&Input, &Output, &Setpoint, Kp, Ki, Kd, DIRECT);

// Function that controls activation or deactivation
// of the relay. The LED built into the Arduino is on when
// the relay is active, otherwise it is off.
void relay_state(bool state) {
    digitalWrite(RELAY_PIN, state);
    digitalWrite(LED_BUILTIN, state);
}

int PID_p = 0;
int PID_i = 0;
int PID_d = 0;
float last_kp = 0;
float last_ki = 0;
float last_kd = 0;
float PID_value = 0;

int PID_values_fixed = 0;

// Oven Temperature : Sensor 1
#define MAX6675_CS 28
#define MAX6675_SO 30
#define MAX6675_SCK 31
float ovenTemperature = 0;

// Reactor Temperature: Sensor 2
int thermo_2SO = 35;
int thermo_2CS = 34;
int thermo_2CLK = 37;
float ReactorTemperature = 0;
MAX6675 thermocouple1(thermo_2CLK, thermo_2CS, thermo_2SO);  // Create an instance for the MAX6675 Sensor 3 Called "thermocouple1"

// Middle Temperature : Sensor 3        ||   Faire attention à celui là
int thermo_3SO = 29;
int thermo_3CS = 33;
int thermo_3CLK = 32;
float middleTemperature = 0;
MAX6675 thermocouple2(thermo_3CLK, thermo_3CS, thermo_3SO);

// Ambiant Temperature : Sensor 3        ||   Faire attention à celui là
int thermo_4SO = 25;
int thermo_4CS = 26;
int thermo_4CLK = 27;
float AmbiantTemperature = 0;
MAX6675 thermocouple3(thermo_4CLK, thermo_4CS, thermo_4SO);

// PRESSURE MESURE:
float tension;  // Variable permettant de stocker la valeur de la tension
float tempC;    // Variable température en °C
float tempK;    // Variable température en kelvins
float PID_LVL = 0;

// Arrays for temperature readings
float tab_oven[10] = {0};
float tab_Reactor[10] = {0};
float tab_middle[10] = {0};
float tab_Ambiant[10] = {0};



                                                                // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// The pins for I2C are defined by the Wire-library. 
// On an arduino UNO:       A4(SDA), A5(SCL)
// On an arduino MEGA 2560: 20(SDA), 21(SCL)
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

static const unsigned char PROGMEM logo_bmp[] ={ 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfc, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0xff, 
	0xfc, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0xff, 
	0xfc, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xe0, 0xff, 
	0xfc, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xff, 
	0xfc, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x00, 0x00, 0x00, 0x7e, 0x0f, 0xff, 0xff, 0x07, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xfc, 0x00, 0x00, 0x00, 0x7e, 0x0f, 0xff, 0xff, 0x03, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x00, 0x00, 0x00, 0x7e, 0x0f, 0xff, 0xff, 0x03, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x00, 0x00, 0x00, 0x7e, 0x0f, 0xff, 0xff, 0x07, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x3f, 0xff, 0xf0, 0x7e, 0x0f, 0xff, 0xff, 0x07, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x3f, 0xff, 0xf0, 0x7e, 0x0f, 0xff, 0xfe, 0x07, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x3f, 0xff, 0xf0, 0x7e, 0x0f, 0xff, 0xfc, 0x07, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xf8, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xfc, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x1f, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xfe, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x7f, 0xc1, 0xff, 0x83, 0xff, 0x83, 0xe0, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

// ===========================
// Initialisation programme
// ========================


void setup() {
     // wait for MAX chip to stabilize
  delay(500);
   // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  // Clear the buffer
  display.clearDisplay();
  logoABMI();      // Draw many lines
  startABMI();    // Draw a small bitmap image

    Serial.begin(9600);

    Serial.println("== == == Get ready for data recording ...  == == ==");
    delay(250);

    // Define relay and led pins as output
    pinMode(RELAY_PIN, OUTPUT);
    pinMode(LED_BUILTIN, OUTPUT);

    // Store current time in variables used by PID and display functions
    windowStartTime = millis();
    lastPrintTime = millis();
    indicateur_boucle=0;

    // Setpoint for the PID temperature control 200 degrees Celsius
    Setpoint = 210;

    // Tell the PID to range between 0 and the full window size
    myPID.SetOutputLimits(0, WindowSize);

    // Turn the PID on
    myPID.SetMode(AUTOMATIC);

    Serial.print("Time");
    Serial.print("  ;  ");
    Serial.print("Temps en ms"); 
    Serial.print("  ;  ");
    Serial.print("T_Rs °C:"); //température mesurée par la sonde 
    Serial.print("  ;  ");
    Serial.print("T_O °C:");
    Serial.print("  ;  ");
    Serial.print("T_M °C:");
    Serial.print("  ;  ");
    // Serial.print("T_Am °C:");
    // Serial.print("  ;  ");
    Serial.print("OvenPower %:");
    Serial.print("  ;  ");
    Serial.print("Output :");
    Serial.print("    ; ");
    // Serial.print("errKp");
    // Serial.print("    ; ");
    // Serial.print("errKi");
    // Serial.print("    ; ");
    // Serial.print("errKd");
    Serial.print("Indicateur Boucle :");
    Serial.println();
}

void logoABMI() {

  display.clearDisplay();
  display.drawBitmap(
    (display.width()  - SCREEN_WIDTH ) / 2,      // Position de l'extrême "gauche" de l'image (pour centrage écran, ici)
    (display.height() - SCREEN_HEIGHT) / 2,       // Position de l'extrême "haute" de l'image (pour centrage écran, ici)
    logo_bmp,
    SCREEN_WIDTH,
    SCREEN_HEIGHT,
    WHITE);                                           // "couleur" de l'image
  delay(50);                     // Delay of 200 ms

  // Show initial display 
  display.clearDisplay();
  display.drawBitmap(
    (display.width()  - SCREEN_WIDTH ) / 2,      // Position de l'extrême "gauche" de l'image (pour centrage écran, ici)
    (display.height() - SCREEN_HEIGHT) / 2,       // Position de l'extrême "haute" de l'image (pour centrage écran, ici)
    logo_bmp,
    SCREEN_WIDTH,
    SCREEN_HEIGHT,
    WHITE);                                           // "couleur" de l'image
    display.display(); // Update screen
    delay(5000);                     // Delay of 200 ms
    display.clearDisplay();
}

void startABMI(void) {

  display.setTextSize(2);          // Set text Size
  display.setTextColor(WHITE);     // set LCD Colour
  display.setCursor(48, 0);        // Set Cursor Position
  display.println("PID");          // Print the this Text
  display.setCursor(49, 20);        // Set Cursor Position
  display.setTextSize(2);          // Set text Size
  display.println("T");  // Print the this Text
  display.setCursor(63, 20);        // Set Cursor Position
  display.setTextSize(1);
  display.cp437(true);
  display.write(167);
  display.setTextSize(2);
  display.print("C");
  display.setCursor(25, 35);       // Set Cursor Position
  display.setTextSize(2);          // Set text Size
  display.println("Control");      // Print the this Text
  display.display();               // Update the Display
  display.setTextSize(1);
  display.setCursor(10,57);
  display.print(" HTC Project _ R&I ");
  display.display();
  delay(2000);                     // Delay of 200 ms

}

void loop() {
    float total_oven = 0;
    float total_Reactor = 0;
    float total_middle = 0;
    float total_Ambiant = 0;
    const int readings = 3;

    // Lire la température en Celsius des trois capteurs `readings` fois
    for (int i = 0; i < readings; i++) {
        tab_oven[i] = readThermocouple();
        tab_Reactor[i] = thermocouple1.readCelsius() - 1.0;
        tab_middle[i] = thermocouple2.readCelsius() - 1.0;
        tab_Ambiant[i] = thermocouple3.readCelsius() - 1.0;
        // AmbiantTemperature = thermocouple3.readCelsius();

        total_oven += tab_oven[i];
        total_Reactor += tab_Reactor[i];
        total_middle += tab_middle[i];
        total_Ambiant += tab_Ambiant[i];

        delay(1000); // Attendre 1 seconde avant la prochaine lecture
    }

    // Calculer les moyennes
    ovenTemperature = total_oven / readings;
    ReactorTemperature = total_Reactor / readings;
    middleTemperature = total_middle / readings;
    AmbiantTemperature = total_Ambiant / readings;
 

    // PID computation and relay control
    int sensorVal = analogRead(A15);
    float voltage = ((sensorVal * 5.0) / 1023.0);
    float pressure_pascal = (5.0 * ((float)voltage)) * 1000000.0;
    float pressure_bar = pressure_pascal / 10e5;
    float Rp_Temp = 100 * pow((pressure_bar + 1), 0.25);
    float Rs_Temp = ReactorTemperature;
     

    if (pressure_bar < 0.1) {
        Rp_Temp = 36;

        // Output = WindowSize; // chauffer à 300°C la plaque au départ pour monter à 100°C la température interne
    } 
    if (Rs_Temp < Setpoint-20) {
        relay_state(HIGH);
        Output = WindowSize; // chauffer à 300°C la plaque au départ pour monter à 100°C la température interne
    } 
    else {
        if (Setpoint-20 <= Rs_Temp < Setpoint) {
            // Input = Rp_Temp;
            Input = Rs_Temp;
            error = Setpoint - Input;
            dInput = (Input - lastInput);
            errKp = error * Kp;
            errKi += error * Ki;
            errKd = dInput * Kd / 0.1;
            lastInput = Input;
            myPID.Compute();
        } 
        else if (Rs_Temp <= Setpoint) {
          relay_state(HIGH);
          delay(1000);
          relay_state(LOW);
          indicateur_boucle +=1;
           }     
        else {
            myPID.SetTunings(consKp, consKi, consKd);
            Ki = consKi;
            Kd = consKd;
            // Input = Rp_Temp;
            Input = Rs_Temp;
            error = Setpoint - Input;
            dInput = (Input - lastInput);
            errKp = error * Kp;
            errKi += error * Ki;
            errKd = dInput * Kd / 0.1;
            lastInput = Input;
            myPID.Compute();
        }
    }

    // Relay control
    while (millis() - windowStartTime < WindowSize) {
        if (ovenTemperature > temperatureOfSecurity) {
            relay_state(LOW);
            Output = 0;
        } 
        else if (Output < millis() - windowStartTime) {
            relay_state(LOW); 
        } else {
            relay_state(HIGH);
        }
    }

    windowStartTime += WindowSize;

    int ovenPower = map(Output, 0, WindowSize, 0, 100);

    // The current time for the parameters acquisitions
    time_t t = now();
    String myStringHour = String(hour(t));
    String myStringMinute = String(minute(t));
    String myStringSecond = String(second(t));
    String myStringTime = myStringHour + ":" + myStringMinute + ":" + myStringSecond;

    Serial.print(myStringTime);
    Serial.print("  ;  ");
    Serial.print(millis());
    Serial.print("    ;  ");
    Serial.print(ReactorTemperature);
    Serial.print("    ;  ");
    Serial.print(ovenTemperature);
    Serial.print("    ;  ");
    Serial.print(middleTemperature);
    Serial.print("    ;  ");
    // Serial.print(AmbiantTemperature);
    // Serial.print("    ;  ");
    Serial.print(ovenPower);
    Serial.print("    ;  ");
    Serial.print(Output);
    Serial.print("    ;  ");
    Serial.print(indicateur_boucle);
    Serial.println();

  //////////////////////////////////////////////////// OLED DISPLAY _ REACTOR 

  display.clearDisplay(); // Clear the display
  display.setTextSize(2); // Set text Size
  display.setCursor(0, 0); // Set the Display Cursor
  display.print("Rs:"); //Print to the Display
  display.setTextSize(1);
  display.cp437(true);
  display.write(167);
  display.setTextSize(1);
  display.print("C");
  display.setTextSize(2);
  display.setCursor(55, 0);// Set the Display Cursor
  display.print(ReactorTemperature); // Print the Temperature value to the display in celciuS
 
  //////////////////////////////////////////////////// OLED DISPLAY _ OVEN   
  display.setTextSize(2); // Set text Size
  display.setCursor(0, 17); // Set the Display Cursor
  display.print("O:"); //Print to the Display
  display.setTextSize(1);
  display.cp437(true);
  display.write(167);
  display.setTextSize(1);
  display.print("C");
  display.setTextSize(2);
  display.setCursor(55, 17);// Set the Display Cursor
  display.print(ovenTemperature); // Print the Temperature value to the display in celciuS
  //////////////////////////////////////////////////// OLED DISPLAY _ MIDDLE  
  display.setTextSize(2); // Set text Size
  display.setCursor(0, 34); // Set the Display Cursor
  display.print("M:"); //Print to the Display
  display.setTextSize(1);
  display.cp437(true);
  display.write(167);
  display.setTextSize(1);
  display.print("C");
  display.setTextSize(2);
  display.setCursor(55, 34);// Set the Display Cursor
  display.print(middleTemperature); // Print the Temperature value to the display in celciuS
  
  // //////////////////////////////////////////////////// OLED DISPLAY _ SETTING 
  display.setTextSize(2);          // Set text Size
  display.setCursor(0,51);        // set the diplay cursor
  display.print("P:");      // Print Set Temp. on the display
  display.setTextSize(1);
  display.print("bar");
  display.setTextSize(2);          // Set text Size
  display.setCursor(55, 51);       // set the cursor
  display.print(pressure_bar);  // print the set temperature value on the display

  display.display();
  delay(250);

}

// The function that reads the SPI data from MAX6675
double readThermocouple() {
    uint16_t v;
    pinMode(MAX6675_CS, OUTPUT);
    pinMode(MAX6675_SO, INPUT);
    pinMode(MAX6675_SCK, OUTPUT);

    digitalWrite(MAX6675_CS, LOW);
    delay(1);

    v = shiftIn(MAX6675_SO, MAX6675_SCK, MSBFIRST);
    v <<= 8;
        v |= shiftIn(MAX6675_SO, MAX6675_SCK, MSBFIRST);

    digitalWrite(MAX6675_CS, HIGH);
    if (v & 0x4) {
        // Bit 2 indicates if the thermocouple is disconnected
        return NAN;
    }

    // The lower three bits (0,1,2) are discarded status bits
    v >>= 3;

    // The remaining bits are the number of 0.25 degree (C) counts
    return v * 0.25;
}
